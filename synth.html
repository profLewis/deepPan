<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steel Pan Synthesizer - deepPan</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }
        h1 {
            text-align: center;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #C0C0C0, #FFD700, #C0C0C0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { text-align: center; color: #888; margin-bottom: 20px; }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
        }

        .pan-section {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 20px;
        }
        .controls-section {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 20px;
        }

        /* Piano-style keyboard */
        .keyboard {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }
        .ring-row {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
        }
        .ring-label {
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
        .note-btn {
            width: 50px;
            height: 45px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 11px;
            transition: all 0.1s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .note-btn:hover { transform: scale(1.05); filter: brightness(1.2); }
        .note-btn:active, .note-btn.playing {
            transform: scale(0.95);
            filter: brightness(1.5);
            box-shadow: 0 0 15px currentColor;
        }
        .note-btn.outer { background: #c0392b; color: white; }
        .note-btn.central { background: #2471a3; color: white; }
        .note-btn.inner { background: #1e8449; color: white; }
        .note-btn .freq { font-size: 9px; opacity: 0.7; }

        /* Controls */
        .control-group {
            margin-bottom: 20px;
        }
        .control-group h3 {
            font-size: 14px;
            color: #FFD700;
            margin-bottom: 10px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }
        .slider-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
        }
        .slider-row label {
            width: 80px;
            font-size: 12px;
            color: #aaa;
        }
        .slider-row input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #FFD700;
            border-radius: 50%;
            cursor: pointer;
        }
        .slider-row .value {
            width: 50px;
            text-align: right;
            font-size: 11px;
            color: #888;
            font-family: monospace;
        }

        /* Presets */
        .presets {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        .preset-btn {
            padding: 6px 12px;
            background: #333;
            border: 1px solid #555;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 11px;
        }
        .preset-btn:hover { background: #444; }
        .preset-btn.active { background: #FFD700; color: black; }

        /* Now playing */
        .now-playing {
            text-align: center;
            padding: 15px;
            background: rgba(255,215,0,0.1);
            border-radius: 10px;
            margin-bottom: 15px;
        }
        .now-playing .note { font-size: 24px; color: #FFD700; }
        .now-playing .info { font-size: 12px; color: #888; }

        /* Visualization displays */
        .viz-section {
            margin-bottom: 15px;
        }
        .viz-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .viz-container {
            flex: 1;
            background: #111;
            border-radius: 8px;
            padding: 8px;
        }
        .viz-container.half {
            flex: 1;
        }
        .viz-label {
            font-size: 10px;
            color: #666;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .viz-canvas {
            width: 100%;
            height: 70px;
            display: block;
            background: #0a0a0a;
        }
        .viz-modes {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .viz-mode-btn {
            padding: 4px 10px;
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            color: #888;
            font-size: 10px;
            cursor: pointer;
        }
        .viz-mode-btn:hover { background: #333; }
        .viz-mode-btn.active { background: #FFD700; color: #000; border-color: #FFD700; }

        /* Keyboard hints */
        .keyboard-hint {
            text-align: center;
            font-size: 11px;
            color: #666;
            margin-top: 10px;
        }

        /* CLI command display */
        .cli-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
        .cli-section h3 {
            font-size: 14px;
            color: #FFD700;
            margin-bottom: 10px;
        }
        .file-btns {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .file-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
        }
        .file-btn.save { background: #2980b9; color: white; }
        .file-btn.save:hover { background: #3498db; }
        .file-btn.load { background: #27ae60; color: white; }
        .file-btn.load:hover { background: #2ecc71; }
        .file-input { display: none; }
        .file-status {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
            min-height: 16px;
        }
        .cli-command {
            width: 100%;
            padding: 10px;
            background: #000;
            border: 1px solid #333;
            border-radius: 8px;
            color: #0f0;
            font-family: monospace;
            font-size: 11px;
            word-break: break-all;
            line-height: 1.4;
        }
        .cli-command .cmd { color: #0f0; }
        .cli-command .opt { color: #888; }

        /* Sequence input */
        .sequence-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
        .sequence-input {
            width: 100%;
            padding: 10px;
            background: #222;
            border: 1px solid #444;
            border-radius: 8px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            margin-bottom: 10px;
        }
        .sequence-btns {
            display: flex;
            gap: 10px;
        }
        .sequence-btns button {
            flex: 1;
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            border-radius: 5px;
            color: white;
            cursor: pointer;
        }
        .sequence-btns button:hover { background: #444; }
        .sequence-btns button.play { background: #1e8449; }
        .sequence-btns button.stop { background: #c0392b; }
    </style>
</head>
<body>
    <h1>Steel Pan Synthesizer</h1>
    <p class="subtitle">Click notes or use keyboard (A-L, Q-P) to play</p>

    <div class="container">
        <div class="pan-section">
            <div class="now-playing">
                <div class="note" id="nowPlaying">-</div>
                <div class="info" id="nowPlayingInfo">Click a note to play</div>
            </div>

            <div class="viz-section">
                <div class="viz-modes">
                    <button class="viz-mode-btn active" onclick="setVizMode('waveform')">Waveform</button>
                    <button class="viz-mode-btn" onclick="setVizMode('spectrum')">Spectrum</button>
                    <button class="viz-mode-btn" onclick="setVizMode('lissajous')">Lissajous</button>
                    <button class="viz-mode-btn" onclick="setVizMode('bars')">Bars</button>
                </div>
                <div class="viz-row">
                    <div class="viz-container half">
                        <div class="viz-label">Live Audio</div>
                        <canvas class="viz-canvas" id="liveViz"></canvas>
                    </div>
                    <div class="viz-container half">
                        <div class="viz-label">ADSR Envelope</div>
                        <canvas class="viz-canvas" id="envelopeViz"></canvas>
                    </div>
                </div>
                <div class="viz-row">
                    <div class="viz-container half">
                        <div class="viz-label">Harmonic Spectrum</div>
                        <canvas class="viz-canvas" id="harmonicViz"></canvas>
                    </div>
                    <div class="viz-container half">
                        <div class="viz-label">Synthesized Waveform</div>
                        <canvas class="viz-canvas" id="synthWaveViz"></canvas>
                    </div>
                </div>
            </div>

            <div class="keyboard">
                <!-- Inner Ring -->
                <div class="ring-row">
                    <div class="ring-label">Inner Ring (Octave 6)</div>
                </div>
                <div class="ring-row" id="innerRing"></div>

                <!-- Central Ring -->
                <div class="ring-row">
                    <div class="ring-label">Central Ring (Octave 5)</div>
                </div>
                <div class="ring-row" id="centralRing"></div>

                <!-- Outer Ring -->
                <div class="ring-row">
                    <div class="ring-label">Outer Ring (Octave 4)</div>
                </div>
                <div class="ring-row" id="outerRing"></div>
            </div>

            <p class="keyboard-hint">Keyboard: Q-P (top row) = Central ring | A-L (home row) = Outer ring | Z-M = Inner ring</p>

            <div class="sequence-section">
                <input type="text" class="sequence-input" id="sequenceInput"
                       placeholder="Enter notes: C4 D4 E4 F4 G4 A4 B4 C5"
                       value="C4 D4 E4 F4 G4 A4 B4 C5">
                <div class="sequence-btns">
                    <button class="play" onclick="playSequence()">Play Sequence</button>
                    <button class="stop" onclick="stopSequence()">Stop</button>
                </div>
            </div>
        </div>

        <div class="controls-section">
            <div class="control-group">
                <h3>Presets</h3>
                <div class="presets">
                    <button class="preset-btn active" onclick="loadPreset('default')">Default</button>
                    <button class="preset-btn" onclick="loadPreset('bright')">Bright</button>
                    <button class="preset-btn" onclick="loadPreset('mellow')">Mellow</button>
                    <button class="preset-btn" onclick="loadPreset('bell')">Bell</button>
                    <button class="preset-btn" onclick="loadPreset('pluck')">Pluck</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Envelope (ADSR)</h3>
                <div class="slider-row">
                    <label>Attack</label>
                    <input type="range" id="attack" min="1" max="200" value="15">
                    <span class="value" id="attackVal">15ms</span>
                </div>
                <div class="slider-row">
                    <label>Decay</label>
                    <input type="range" id="decay" min="50" max="2000" value="500">
                    <span class="value" id="decayVal">500ms</span>
                </div>
                <div class="slider-row">
                    <label>Sustain</label>
                    <input type="range" id="sustain" min="0" max="100" value="20">
                    <span class="value" id="sustainVal">20%</span>
                </div>
                <div class="slider-row">
                    <label>Release</label>
                    <input type="range" id="release" min="50" max="2000" value="300">
                    <span class="value" id="releaseVal">300ms</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Harmonics</h3>
                <div class="slider-row">
                    <label>Fundamental</label>
                    <input type="range" id="fundamental" min="0" max="100" value="100">
                    <span class="value" id="fundamentalVal">100%</span>
                </div>
                <div class="slider-row">
                    <label>2nd Harm</label>
                    <input type="range" id="harm2" min="0" max="100" value="30">
                    <span class="value" id="harm2Val">30%</span>
                </div>
                <div class="slider-row">
                    <label>3rd Harm</label>
                    <input type="range" id="harm3" min="0" max="100" value="10">
                    <span class="value" id="harm3Val">10%</span>
                </div>
                <div class="slider-row">
                    <label>4th Harm</label>
                    <input type="range" id="harm4" min="0" max="100" value="5">
                    <span class="value" id="harm4Val">5%</span>
                </div>
                <div class="slider-row">
                    <label>Sub Bass</label>
                    <input type="range" id="subBass" min="0" max="100" value="20">
                    <span class="value" id="subBassVal">20%</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Character</h3>
                <div class="slider-row">
                    <label>Detune</label>
                    <input type="range" id="detune" min="0" max="20" value="2">
                    <span class="value" id="detuneVal">2 cents</span>
                </div>
                <div class="slider-row">
                    <label>Filter</label>
                    <input type="range" id="filter" min="500" max="10000" value="6000">
                    <span class="value" id="filterVal">6000Hz</span>
                </div>
                <div class="slider-row">
                    <label>Brightness</label>
                    <input type="range" id="brightness" min="0" max="100" value="50">
                    <span class="value" id="brightnessVal">50%</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Output</h3>
                <div class="slider-row">
                    <label>Duration</label>
                    <input type="range" id="duration" min="0.5" max="3.0" step="0.1" value="1.5">
                    <span class="value" id="durationVal">1.5s</span>
                </div>
                <div class="slider-row">
                    <label>Volume</label>
                    <input type="range" id="volume" min="0" max="100" value="85">
                    <span class="value" id="volumeVal">85%</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Playback</h3>
                <div class="slider-row">
                    <label>BPM</label>
                    <input type="range" id="bpm" min="60" max="200" value="120">
                    <span class="value" id="bpmVal">120</span>
                </div>
            </div>

            <div class="cli-section">
                <h3>Equivalent CLI Command</h3>
                <div class="cli-command" id="cliCommand">python generate_sounds.py</div>
                <div class="file-btns">
                    <button class="file-btn save" onclick="saveParams()">Save Params</button>
                    <button class="file-btn load" onclick="document.getElementById('paramsFile').click()">Load Params</button>
                    <input type="file" id="paramsFile" class="file-input" accept=".json" onchange="loadParams(event)">
                </div>
                <div class="file-status" id="fileStatus"></div>
            </div>

            <div class="cli-section">
                <h3>Analyze Audio Sample</h3>
                <p style="font-size: 11px; color: #888; margin-bottom: 10px;">Load WAV file(s) to extract synthesis parameters</p>
                <div class="file-btns">
                    <button class="file-btn load" onclick="document.getElementById('audioFile').click()" style="background: #8e44ad;">Analyze WAV(s)</button>
                    <input type="file" id="audioFile" class="file-input" accept=".wav,audio/wav" multiple onchange="analyzeMultipleAudio(event)">
                </div>
                <div id="analysisResult" style="margin-top: 10px; font-size: 11px; color: #aaa;"></div>
                <div id="fileList" style="margin-top: 10px; display: none;">
                    <div class="viz-label">Analyzed Files (click to select)</div>
                    <div id="fileListContent" style="max-height: 120px; overflow-y: auto; background: #111; border-radius: 5px; padding: 5px;"></div>
                </div>
                <div class="viz-container" style="margin-top: 10px; display: none;" id="loadedAudioVizContainer">
                    <div class="viz-label">Loaded Audio Waveform</div>
                    <canvas class="viz-canvas" id="loadedAudioViz"></canvas>
                </div>
                <div class="file-btns" style="margin-top: 10px; display: none;" id="applyBtns">
                    <button class="file-btn" onclick="applyAnalyzedParams()" style="background: #27ae60;">Apply to Synth</button>
                    <button class="file-btn" onclick="playLoadedAudio()" style="background: #2980b9;">Play Original</button>
                </div>
            </div>
        </div>
    </div>

<script>
// Note definitions
const NOTE_FREQUENCIES = {
    'C': 261.63, 'C#': 277.18, 'Db': 277.18,
    'D': 293.66, 'D#': 311.13, 'Eb': 311.13,
    'E': 329.63,
    'F': 349.23, 'F#': 369.99, 'Gb': 369.99,
    'G': 392.00, 'G#': 415.30, 'Ab': 415.30,
    'A': 440.00, 'A#': 466.16, 'Bb': 466.16,
    'B': 493.88
};

const NOTE_MAP = {
    // Inner Ring (5 notes, octave 6)
    'I0': { note: 'C#', octave: 6, ring: 'inner' },
    'I1': { note: 'E', octave: 6, ring: 'inner' },
    'I2': { note: 'D', octave: 6, ring: 'inner' },
    'I3': { note: 'C', octave: 6, ring: 'inner' },
    'I4': { note: 'Eb', octave: 6, ring: 'inner' },

    // Central Ring (12 notes, octave 5)
    'C0': { note: 'F#', octave: 5, ring: 'central' },
    'C1': { note: 'B', octave: 5, ring: 'central' },
    'C2': { note: 'E', octave: 5, ring: 'central' },
    'C3': { note: 'A', octave: 5, ring: 'central' },
    'C4': { note: 'D', octave: 5, ring: 'central' },
    'C5': { note: 'G', octave: 5, ring: 'central' },
    'C6': { note: 'C', octave: 5, ring: 'central' },
    'C7': { note: 'F', octave: 5, ring: 'central' },
    'C8': { note: 'Bb', octave: 5, ring: 'central' },
    'C9': { note: 'Eb', octave: 5, ring: 'central' },
    'C10': { note: 'Ab', octave: 5, ring: 'central' },
    'C11': { note: 'C#', octave: 5, ring: 'central' },

    // Outer Ring (12 notes, octave 4)
    'O0': { note: 'F#', octave: 4, ring: 'outer' },
    'O1': { note: 'B', octave: 4, ring: 'outer' },
    'O2': { note: 'E', octave: 4, ring: 'outer' },
    'O3': { note: 'A', octave: 4, ring: 'outer' },
    'O4': { note: 'D', octave: 4, ring: 'outer' },
    'O5': { note: 'G', octave: 4, ring: 'outer' },
    'O6': { note: 'C', octave: 4, ring: 'outer' },
    'O7': { note: 'F', octave: 4, ring: 'outer' },
    'O8': { note: 'Bb', octave: 4, ring: 'outer' },
    'O9': { note: 'Eb', octave: 4, ring: 'outer' },
    'O10': { note: 'Ab', octave: 4, ring: 'outer' },
    'O11': { note: 'C#', octave: 4, ring: 'outer' }
};

// Keyboard mapping
const KEY_MAP = {
    // Outer ring (home row)
    'a': 'O0', 's': 'O1', 'd': 'O2', 'f': 'O3', 'g': 'O4', 'h': 'O5',
    'j': 'O6', 'k': 'O7', 'l': 'O8', ';': 'O9', "'": 'O10', '\\': 'O11',
    // Central ring (top row)
    'q': 'C0', 'w': 'C1', 'e': 'C2', 'r': 'C3', 't': 'C4', 'y': 'C5',
    'u': 'C6', 'i': 'C7', 'o': 'C8', 'p': 'C9', '[': 'C10', ']': 'C11',
    // Inner ring (bottom row)
    'z': 'I0', 'x': 'I1', 'c': 'I2', 'v': 'I3', 'b': 'I4'
};

// Presets - match generate_sounds.py exactly
const PRESETS = {
    default: {
        attack: 15, decay: 500, sustain: 20, release: 300,
        fundamental: 100, harm2: 30, harm3: 10, harm4: 5, subBass: 20,
        detune: 2, filter: 6000, brightness: 50, duration: 1.5, volume: 85
    },
    bright: {
        attack: 5, decay: 300, sustain: 10, release: 200,
        fundamental: 80, harm2: 50, harm3: 30, harm4: 20, subBass: 10,
        detune: 3, filter: 10000, brightness: 80, duration: 1.5, volume: 85
    },
    mellow: {
        attack: 30, decay: 800, sustain: 30, release: 500,
        fundamental: 100, harm2: 15, harm3: 5, harm4: 2, subBass: 30,
        detune: 1, filter: 3000, brightness: 30, duration: 1.5, volume: 85
    },
    bell: {
        attack: 2, decay: 1500, sustain: 5, release: 1000,
        fundamental: 70, harm2: 60, harm3: 40, harm4: 30, subBass: 5,
        detune: 5, filter: 8000, brightness: 60, duration: 1.5, volume: 85
    },
    pluck: {
        attack: 1, decay: 200, sustain: 0, release: 100,
        fundamental: 100, harm2: 40, harm3: 20, harm4: 10, subBass: 15,
        detune: 0, filter: 5000, brightness: 50, duration: 1.5, volume: 85
    }
};

// Audio context and nodes
let audioCtx = null;
let convolver = null;
let masterGain = null;
let analyser = null;
let sequenceInterval = null;

// Initialize audio context
function initAudio() {
    if (audioCtx) return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Master gain
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.7;

    // Analyser for waveform
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;

    // Convolver for reverb
    convolver = audioCtx.createConvolver();
    createReverb();

    // Dry/wet mix
    const dryGain = audioCtx.createGain();
    const wetGain = audioCtx.createGain();
    dryGain.gain.value = 0.7;
    wetGain.gain.value = 0.3;

    masterGain.connect(dryGain);
    masterGain.connect(convolver);
    convolver.connect(wetGain);
    dryGain.connect(analyser);
    wetGain.connect(analyser);
    analyser.connect(audioCtx.destination);
}

// Create impulse response for reverb
function createReverb() {
    const rate = audioCtx.sampleRate;
    const length = rate * 2;
    const impulse = audioCtx.createBuffer(2, length, rate);

    for (let channel = 0; channel < 2; channel++) {
        const data = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
        }
    }

    convolver.buffer = impulse;
}

// Get frequency for note
function getFrequency(noteName, octave) {
    const baseFreq = NOTE_FREQUENCIES[noteName];
    if (!baseFreq) return 440;
    return baseFreq * Math.pow(2, octave - 4);
}

// Get current synth parameters
function getParams() {
    return {
        attack: parseInt(document.getElementById('attack').value) / 1000,
        decay: parseInt(document.getElementById('decay').value) / 1000,
        sustain: parseInt(document.getElementById('sustain').value) / 100,
        release: parseInt(document.getElementById('release').value) / 1000,
        fundamental: parseInt(document.getElementById('fundamental').value) / 100,
        harm2: parseInt(document.getElementById('harm2').value) / 100,
        harm3: parseInt(document.getElementById('harm3').value) / 100,
        harm4: parseInt(document.getElementById('harm4').value) / 100,
        subBass: parseInt(document.getElementById('subBass').value) / 100,
        detune: parseInt(document.getElementById('detune').value),
        filter: parseInt(document.getElementById('filter').value),
        brightness: parseInt(document.getElementById('brightness').value) / 100,
        duration: parseFloat(document.getElementById('duration').value),
        volume: parseInt(document.getElementById('volume').value) / 100
    };
}

// Get raw parameter values for CLI command
function getRawParams() {
    return {
        attack: parseInt(document.getElementById('attack').value),
        decay: parseInt(document.getElementById('decay').value),
        sustain: parseInt(document.getElementById('sustain').value),
        release: parseInt(document.getElementById('release').value),
        fundamental: parseInt(document.getElementById('fundamental').value),
        harmonic2: parseInt(document.getElementById('harm2').value),
        harmonic3: parseInt(document.getElementById('harm3').value),
        harmonic4: parseInt(document.getElementById('harm4').value),
        'sub-bass': parseInt(document.getElementById('subBass').value),
        detune: parseInt(document.getElementById('detune').value),
        filter: parseInt(document.getElementById('filter').value),
        brightness: parseInt(document.getElementById('brightness').value),
        duration: parseFloat(document.getElementById('duration').value),
        volume: parseInt(document.getElementById('volume').value)
    };
}

// Save parameters to JSON file
function saveParams() {
    const params = getRawParams();
    const json = JSON.stringify(params, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'synth_params.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    document.getElementById('fileStatus').textContent = 'Saved: synth_params.json';
    setTimeout(() => document.getElementById('fileStatus').textContent = '', 3000);
}

// Load parameters from JSON file
function loadParams(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const loaded = JSON.parse(e.target.result);
            
            // Map keys (handle different naming conventions)
            const keyMap = {
                'sub_bass': 'subBass',
                'harmonic2': 'harm2',
                'harmonic3': 'harm3',
                'harmonic4': 'harm4',
            };
            
            // Apply loaded values to sliders
            for (let [key, value] of Object.entries(loaded)) {
                // Convert key if needed
                const sliderKey = keyMap[key] || key;
                const slider = document.getElementById(sliderKey);
                if (slider) {
                    slider.value = value;
                    updateSliderDisplay(sliderKey);
                }
            }
            
            validateADSR();
            updateCLICommand();
            updateStaticViz();
            
            document.getElementById('fileStatus').textContent = 'Loaded: ' + file.name;
            setTimeout(() => document.getElementById('fileStatus').textContent = '', 3000);
        } catch (err) {
            document.getElementById('fileStatus').textContent = 'Error loading file';
            console.error('Load error:', err);
        }
    };
    reader.readAsText(file);
    
    // Reset file input
    event.target.value = '';
}

// Default values for CLI comparison
const CLI_DEFAULTS = {
    attack: 15, decay: 500, sustain: 20, release: 300,
    fundamental: 100, harmonic2: 30, harmonic3: 10, harmonic4: 5,
    'sub-bass': 20, detune: 2, filter: 6000, brightness: 50,
    duration: 1.5, volume: 85
};

// Update CLI command display
function updateCLICommand() {
    const params = getRawParams();
    let cmd = 'python generate_sounds.py';
    let hasChanges = false;

    // Check each param against defaults
    for (const [key, value] of Object.entries(params)) {
        if (value !== CLI_DEFAULTS[key]) {
            hasChanges = true;
            cmd += ` --${key} ${value}`;
        }
    }

    document.getElementById('cliCommand').textContent = cmd;
}

// Play a note
function playNote(noteId) {
    initAudio();

    const noteData = NOTE_MAP[noteId];
    if (!noteData) return;

    const freq = getFrequency(noteData.note, noteData.octave);
    const params = getParams();
    const now = audioCtx.currentTime;

    // Update display
    document.getElementById('nowPlaying').textContent = `${noteData.note}${noteData.octave}`;
    document.getElementById('nowPlayingInfo').textContent = `${freq.toFixed(1)} Hz | ${noteId}`;

    // Highlight button
    const btn = document.querySelector(`[data-note="${noteId}"]`);
    if (btn) {
        btn.classList.add('playing');
        setTimeout(() => btn.classList.remove('playing'), 200);
    }

    // Create oscillators for each harmonic
    const harmonics = [
        { ratio: 0.5, amp: params.subBass },
        { ratio: 1.0 - params.detune/1000, amp: params.fundamental * 0.1 },
        { ratio: 1.0, amp: params.fundamental },
        { ratio: 1.0 + params.detune/1000, amp: params.fundamental * 0.1 },
        { ratio: 2.0, amp: params.harm2 },
        { ratio: 3.0, amp: params.harm3 },
        { ratio: 4.0, amp: params.harm4 }
    ];

    // Create a gain node for this note
    const noteGain = audioCtx.createGain();
    noteGain.gain.value = 0;

    // Low-pass filter
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = params.filter;
    filter.Q.value = 0.5;

    noteGain.connect(filter);

    // Brightness (high-shelf filter)
    if (params.brightness !== 0.5) {
        const brightFilter = audioCtx.createBiquadFilter();
        brightFilter.type = 'highshelf';
        brightFilter.frequency.value = 2000;
        brightFilter.gain.value = (params.brightness - 0.5) * 12; // -6dB to +6dB
        filter.connect(brightFilter);
        brightFilter.connect(masterGain);
    } else {
        filter.connect(masterGain);
    }

    // Update master volume
    masterGain.gain.value = params.volume;

    // Create oscillators
    harmonics.forEach(h => {
        if (h.amp < 0.01) return;

        const osc = audioCtx.createOscillator();
        const oscGain = audioCtx.createGain();

        osc.type = 'sine';
        osc.frequency.value = freq * h.ratio;
        oscGain.gain.value = h.amp * 0.3;

        osc.connect(oscGain);
        oscGain.connect(noteGain);

        osc.start(now);
        osc.stop(now + params.attack + params.decay + params.release + 0.5);
    });

    // ADSR envelope
    const peakTime = now + params.attack;
    const sustainTime = peakTime + params.decay;
    const endTime = sustainTime + params.release;

    noteGain.gain.setValueAtTime(0, now);
    noteGain.gain.linearRampToValueAtTime(1, peakTime);
    noteGain.gain.linearRampToValueAtTime(params.sustain, sustainTime);
    noteGain.gain.linearRampToValueAtTime(0, endTime);
}

// Play note by name (e.g., "C4", "F#5")
function playNoteByName(name) {
    // Parse note name
    const match = name.match(/^([A-Ga-g][#b]?)(\d)$/);
    if (!match) return false;

    let noteName = match[1].toUpperCase();
    const octave = parseInt(match[2]);

    // Find matching note in NOTE_MAP
    for (const [id, data] of Object.entries(NOTE_MAP)) {
        if (data.note === noteName && data.octave === octave) {
            playNote(id);
            return true;
        }
        // Handle enharmonic equivalents
        if (noteName === 'Db' && data.note === 'C#' && data.octave === octave) {
            playNote(id);
            return true;
        }
        if (noteName === 'Gb' && data.note === 'F#' && data.octave === octave) {
            playNote(id);
            return true;
        }
    }
    return false;
}

// Play sequence
function playSequence() {
    stopSequence();

    const input = document.getElementById('sequenceInput').value;
    const notes = input.split(/[\s,]+/).filter(n => n.length > 0);
    const bpm = parseInt(document.getElementById('bpm').value);
    const interval = 60000 / bpm;

    let index = 0;
    sequenceInterval = setInterval(() => {
        if (index >= notes.length) {
            stopSequence();
            return;
        }

        const note = notes[index];
        if (note !== '-' && note !== '.' && note !== 'r') {
            playNoteByName(note);
        }
        index++;
    }, interval);
}

function stopSequence() {
    if (sequenceInterval) {
        clearInterval(sequenceInterval);
        sequenceInterval = null;
    }
}

// Load preset
function loadPreset(name) {
    const preset = PRESETS[name];
    if (!preset) return;

    document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
    document.querySelector(`[onclick="loadPreset('${name}')"]`).classList.add('active');

    Object.entries(preset).forEach(([key, value]) => {
        const input = document.getElementById(key);
        if (input) {
            input.value = value;
            updateSliderDisplay(key);
        }
    });

    validateADSR();
    updateCLICommand();
    updateStaticViz();
}

// Update slider display
function updateSliderDisplay(id) {
    const input = document.getElementById(id);
    const display = document.getElementById(id + 'Val');
    if (!input || !display) return;

    const value = input.value;
    const units = {
        attack: 'ms', decay: 'ms', release: 'ms',
        sustain: '%', fundamental: '%', harm2: '%', harm3: '%', harm4: '%', subBass: '%',
        detune: ' cents', filter: 'Hz', brightness: '%', duration: 's', volume: '%', bpm: ''
    };

    display.textContent = value + (units[id] || '');
}

// Visualization mode
let vizMode = 'waveform';

function setVizMode(mode) {
    vizMode = mode;
    document.querySelectorAll('.viz-mode-btn').forEach(btn => {
        btn.classList.toggle('active', btn.textContent.toLowerCase() === mode);
    });
}

// Helper to setup canvas with proper sizing
function setupCanvas(canvas) {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    return { ctx, width: rect.width, height: rect.height };
}

// Draw live visualization (oscilloscope-style)
function drawLiveViz() {
    const canvas = document.getElementById('liveViz');
    if (!canvas) {
        requestAnimationFrame(drawLiveViz);
        return;
    }

    const rect = canvas.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) {
        requestAnimationFrame(drawLiveViz);
        return;
    }

    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    const width = rect.width;
    const height = rect.height;

    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, width, height);

    // Draw grid
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 1;
    for (let i = 0; i < 10; i++) {
        ctx.beginPath();
        ctx.moveTo(i * width / 10, 0);
        ctx.lineTo(i * width / 10, height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * height / 10);
        ctx.lineTo(width, i * height / 10);
        ctx.stroke();
    }

    if (!analyser) {
        requestAnimationFrame(drawLiveViz);
        return;
    }

    const bufferLength = analyser.frequencyBinCount;
    const timeData = new Uint8Array(bufferLength);
    const freqData = new Uint8Array(bufferLength);
    analyser.getByteTimeDomainData(timeData);
    analyser.getByteFrequencyData(freqData);

    ctx.lineWidth = 1.5;

    if (vizMode === 'waveform') {
        // Classic oscilloscope waveform
        ctx.strokeStyle = '#00ff88';
        ctx.beginPath();
        const sliceWidth = width / bufferLength;
        let x = 0;
        for (let i = 0; i < bufferLength; i++) {
            const v = timeData[i] / 128.0;
            const y = v * height / 2;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
            x += sliceWidth;
        }
        ctx.stroke();

    } else if (vizMode === 'spectrum') {
        // Frequency spectrum
        const barWidth = width / 48;
        for (let i = 0; i < 48; i++) {
            const value = freqData[i * 4] / 255;
            const barHeight = value * height * 0.9;
            const hue = 120 - value * 80;
            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.fillRect(i * barWidth, height - barHeight, barWidth - 1, barHeight);
        }

    } else if (vizMode === 'lissajous') {
        // Lissajous pattern (X-Y mode)
        ctx.strokeStyle = '#ff6600';
        ctx.beginPath();
        for (let i = 0; i < bufferLength - 1; i++) {
            const x = (timeData[i] / 255) * width;
            const y = (timeData[i + 1] / 255) * height;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();

    } else if (vizMode === 'bars') {
        // VU-meter style bars
        const numBars = 32;
        const barWidth = width / numBars;
        for (let i = 0; i < numBars; i++) {
            const value = freqData[i * 8] / 255;
            const segments = Math.floor(value * 12);
            for (let j = 0; j < segments; j++) {
                const segHeight = height / 14;
                const y = height - (j + 1) * segHeight;
                if (j < 6) ctx.fillStyle = '#00ff00';
                else if (j < 9) ctx.fillStyle = '#ffff00';
                else ctx.fillStyle = '#ff0000';
                ctx.fillRect(i * barWidth + 2, y, barWidth - 4, segHeight - 2);
            }
        }
    }

    requestAnimationFrame(drawLiveViz);
}

// Validate ADSR parameters - ensure they fit within duration
function validateADSR() {
    const attackEl = document.getElementById('attack');
    const decayEl = document.getElementById('decay');
    const releaseEl = document.getElementById('release');
    const durationEl = document.getElementById('duration');

    let attack = parseInt(attackEl.value);
    let decay = parseInt(decayEl.value);
    let release = parseInt(releaseEl.value);
    const duration = parseFloat(durationEl.value) * 1000;

    const total = attack + decay + release;
    const maxADR = duration * 0.95; // Leave 5% for sustain portion

    // If total exceeds duration, scale down proportionally
    if (total > maxADR) {
        const scale = maxADR / total;
        attack = Math.max(1, Math.floor(attack * scale));
        decay = Math.max(50, Math.floor(decay * scale));
        release = Math.max(50, Math.floor(release * scale));

        // Update sliders silently (without triggering change events)
        attackEl.value = attack;
        decayEl.value = decay;
        releaseEl.value = release;

        // Update displays
        document.getElementById('attackVal').textContent = attack + 'ms';
        document.getElementById('decayVal').textContent = decay + 'ms';
        document.getElementById('releaseVal').textContent = release + 'ms';

        return true; // Parameters were adjusted
    }
    return false;
}

// Draw ADSR envelope visualization (static, updates with params)
function drawEnvelopeViz() {
    const canvas = document.getElementById('envelopeViz');
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    const width = rect.width;
    const height = rect.height;
    const padding = 8;

    // Get envelope params (already validated)
    const attack = parseInt(document.getElementById('attack').value);
    const decay = parseInt(document.getElementById('decay').value);
    const sustain = parseInt(document.getElementById('sustain').value) / 100;
    const release = parseInt(document.getElementById('release').value);
    const duration = parseFloat(document.getElementById('duration').value) * 1000;

    // Clear
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, width, height);

    // Grid
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
        ctx.beginPath();
        ctx.moveTo(0, padding + i * (height - 2 * padding) / 4);
        ctx.lineTo(width, padding + i * (height - 2 * padding) / 4);
        ctx.stroke();
    }

    // Calculate time points
    const totalTime = attack + decay + (duration - attack - decay - release) + release;
    const scale = (width - 2 * padding) / totalTime;

    const attackEnd = padding + attack * scale;
    const decayEnd = attackEnd + decay * scale;
    const sustainEnd = padding + (duration - release) * scale;
    const releaseEnd = padding + duration * scale;

    // Draw envelope
    ctx.beginPath();
    ctx.strokeStyle = '#FFD700';
    ctx.lineWidth = 2;

    // Start at 0
    ctx.moveTo(padding, height - padding - 10);

    // Attack: 0 to peak
    ctx.lineTo(attackEnd, padding);

    // Decay: peak to sustain
    ctx.lineTo(decayEnd, padding + (1 - sustain) * (height - 2 * padding - 10));

    // Sustain: hold level
    ctx.lineTo(sustainEnd, padding + (1 - sustain) * (height - 2 * padding - 10));

    // Release: sustain to 0
    ctx.lineTo(releaseEnd, height - padding - 10);

    ctx.stroke();

    // Glow effect
    ctx.strokeStyle = 'rgba(255, 215, 0, 0.2)';
    ctx.lineWidth = 5;
    ctx.stroke();

    // Labels
    ctx.fillStyle = '#888';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('A', attackEnd, height - 2);
    ctx.fillText('D', decayEnd, height - 2);
    ctx.fillText('S', (decayEnd + sustainEnd) / 2, height - 2);
    ctx.fillText('R', sustainEnd + (releaseEnd - sustainEnd) / 2, height - 2);
}

// Draw harmonic spectrum (bar chart)
function drawHarmonicViz() {
    const canvas = document.getElementById('harmonicViz');
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    const width = rect.width;
    const height = rect.height;
    const padding = 8;

    // Get harmonic params
    const harmonics = [
        { name: 'Sub', value: parseInt(document.getElementById('subBass').value), color: '#8844ff' },
        { name: 'Fund', value: parseInt(document.getElementById('fundamental').value), color: '#FFD700' },
        { name: '2nd', value: parseInt(document.getElementById('harm2').value), color: '#00aaff' },
        { name: '3rd', value: parseInt(document.getElementById('harm3').value), color: '#00ff88' },
        { name: '4th', value: parseInt(document.getElementById('harm4').value), color: '#ff6644' },
    ];

    // Clear
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, width, height);

    // Draw bars
    const barWidth = (width - 2 * padding) / harmonics.length;
    const maxHeight = height - 2 * padding - 14;

    harmonics.forEach((h, i) => {
        const x = padding + i * barWidth;
        const barHeight = Math.max(2, (h.value / 100) * maxHeight);
        const y = height - padding - 10 - barHeight;

        // Bar
        ctx.fillStyle = h.color;
        ctx.fillRect(x + 3, y, barWidth - 6, barHeight);

        // Label
        ctx.fillStyle = '#888';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(h.name, x + barWidth / 2, height - 2);

        // Value on top of bar
        if (h.value > 0) {
            ctx.fillStyle = '#fff';
            ctx.font = '8px sans-serif';
            ctx.fillText(h.value, x + barWidth / 2, y - 2);
        }
    });
}

// Draw synthesized waveform preview (one cycle)
function drawSynthWaveViz() {
    const canvas = document.getElementById('synthWaveViz');
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    const width = rect.width;
    const height = rect.height;
    const padding = 8;

    // Get params
    const fundamental = parseInt(document.getElementById('fundamental').value) / 100;
    const harm2 = parseInt(document.getElementById('harm2').value) / 100;
    const harm3 = parseInt(document.getElementById('harm3').value) / 100;
    const harm4 = parseInt(document.getElementById('harm4').value) / 100;
    const subBass = parseInt(document.getElementById('subBass').value) / 100;
    const detune = parseInt(document.getElementById('detune').value) / 1000;

    // Clear
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, width, height);

    // Center line
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, height / 2);
    ctx.lineTo(width, height / 2);
    ctx.stroke();

    // Generate waveform (2 cycles)
    const samples = 200;
    const data = new Float32Array(samples);
    let maxVal = 0;

    for (let i = 0; i < samples; i++) {
        const t = (i / samples) * 4 * Math.PI; // 2 cycles
        let sample = 0;
        sample += subBass * Math.sin(t * 0.5);
        sample += fundamental * Math.sin(t);
        sample += fundamental * 0.1 * Math.sin(t * (1 - detune));
        sample += fundamental * 0.1 * Math.sin(t * (1 + detune));
        sample += harm2 * Math.sin(t * 2);
        sample += harm3 * Math.sin(t * 3);
        sample += harm4 * Math.sin(t * 4);
        data[i] = sample;
        maxVal = Math.max(maxVal, Math.abs(sample));
    }

    // Normalize
    if (maxVal > 0) {
        for (let i = 0; i < samples; i++) data[i] /= maxVal;
    }

    // Draw waveform
    ctx.beginPath();
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 1.5;

    for (let i = 0; i < samples; i++) {
        const x = padding + (i / samples) * (width - 2 * padding);
        const y = height / 2 - data[i] * (height / 2 - padding - 2);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Fill under curve
    ctx.lineTo(width - padding, height / 2);
    ctx.lineTo(padding, height / 2);
    ctx.closePath();
    ctx.fillStyle = 'rgba(0, 255, 255, 0.15)';
    ctx.fill();
}

// Update all static visualizations
function updateStaticViz() {
    drawEnvelopeViz();
    drawHarmonicViz();
    drawSynthWaveViz();
}

// Build keyboard UI
function buildKeyboard() {
    const rings = { inner: 'innerRing', central: 'centralRing', outer: 'outerRing' };

    Object.entries(NOTE_MAP).forEach(([id, data]) => {
        const container = document.getElementById(rings[data.ring]);
        const btn = document.createElement('button');
        btn.className = `note-btn ${data.ring}`;
        btn.dataset.note = id;
        btn.innerHTML = `${data.note}${data.octave}<span class="freq">${getFrequency(data.note, data.octave).toFixed(0)}Hz</span>`;
        btn.onclick = () => playNote(id);
        container.appendChild(btn);
    });
}

// Setup event listeners
function setup() {
    buildKeyboard();

    // Slider listeners
    const adsrParams = ['attack', 'decay', 'release', 'duration'];
    document.querySelectorAll('input[type="range"]').forEach(input => {
        input.addEventListener('input', () => {
            updateSliderDisplay(input.id);
            // Validate ADSR if an envelope param changed
            if (adsrParams.includes(input.id)) {
                validateADSR();
            }
            updateCLICommand();
            updateStaticViz();
        });
        updateSliderDisplay(input.id);
    });

    // Initialize CLI command display
    updateCLICommand();

    // Initialize visualizations after layout is complete
    requestAnimationFrame(() => {
        updateStaticViz();
        drawLiveViz();
    });

    // Keyboard listeners
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT') return;
        const noteId = KEY_MAP[e.key.toLowerCase()];
        if (noteId) {
            e.preventDefault();
            playNote(noteId);
        }
    });

    // Sequence input enter key
    document.getElementById('sequenceInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') playSequence();
    });
}

// =========================================
// AUDIO ANALYSIS FUNCTIONS
// =========================================

let loadedAudioBuffer = null;
let analyzedParams = null;
let allAnalysisResults = [];  // Store multiple analysis results
let selectedResultIndex = 0;  // Currently selected result

// Tenor pan notes for matching
const TENOR_PAN_NOTES = [
    'F#4', 'B4', 'E4', 'A4', 'D4', 'G4', 'C4', 'F4', 'Bb4', 'Eb4', 'Ab4', 'C#4',
    'F#5', 'B5', 'E5', 'A5', 'D5', 'G5', 'C5', 'F5', 'Bb5', 'Eb5', 'Ab5', 'C#5',
    'C#6', 'E6', 'D6', 'C6', 'Eb6'
];

// Convert frequency to note name
function freqToNote(freq) {
    if (freq <= 0) return { note: 'Unknown', octave: 0 };
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const midiNote = Math.round(69 + 12 * Math.log2(freq / 440));
    const octave = Math.floor(midiNote / 12) - 1;
    const noteIdx = midiNote % 12;
    return { note: noteNames[noteIdx], octave: octave };
}

// Detect pitch using autocorrelation
function detectPitchAutocorr(audioData, sampleRate) {
    const minFreq = 50, maxFreq = 2000;
    const segStart = Math.floor(0.05 * sampleRate);
    const segLength = Math.floor(0.2 * sampleRate);
    const segEnd = Math.min(segStart + segLength, audioData.length);

    if (segEnd <= segStart) return 0;

    const segment = audioData.slice(segStart, segEnd);
    const n = segment.length;

    // Normalize
    let mean = 0;
    for (let i = 0; i < n; i++) mean += segment[i];
    mean /= n;
    for (let i = 0; i < n; i++) segment[i] -= mean;

    // Autocorrelation
    const minLag = Math.floor(sampleRate / maxFreq);
    const maxLag = Math.floor(sampleRate / minFreq);

    let maxCorr = 0, bestLag = 0;
    for (let lag = minLag; lag < Math.min(maxLag, n); lag++) {
        let corr = 0;
        for (let i = 0; i < n - lag; i++) {
            corr += segment[i] * segment[i + lag];
        }
        if (corr > maxCorr) {
            maxCorr = corr;
            bestLag = lag;
        }
    }

    return bestLag > 0 ? sampleRate / bestLag : 0;
}

// Detect pitch using FFT
function detectPitchFFT(audioData, sampleRate) {
    const minFreq = 50, maxFreq = 2000;
    const segStart = Math.floor(0.05 * sampleRate);
    const segLength = Math.min(8192, audioData.length - segStart);

    if (segLength <= 0) return 0;

    const segment = audioData.slice(segStart, segStart + segLength);
    const n = segment.length;

    // Apply Hanning window
    for (let i = 0; i < n; i++) {
        segment[i] *= 0.5 * (1 - Math.cos(2 * Math.PI * i / n));
    }

    // Simple DFT for relevant frequencies (faster than full FFT for our needs)
    const numBins = 512;
    const spectrum = new Float32Array(numBins);

    for (let k = 0; k < numBins; k++) {
        const freq = k * sampleRate / n;
        if (freq < minFreq || freq > maxFreq) continue;

        let real = 0, imag = 0;
        for (let i = 0; i < n; i++) {
            const angle = 2 * Math.PI * k * i / n;
            real += segment[i] * Math.cos(angle);
            imag -= segment[i] * Math.sin(angle);
        }
        spectrum[k] = Math.sqrt(real * real + imag * imag);
    }

    // Find peak
    let maxVal = 0, peakBin = 0;
    for (let k = 0; k < numBins; k++) {
        const freq = k * sampleRate / n;
        if (freq >= minFreq && freq <= maxFreq && spectrum[k] > maxVal) {
            maxVal = spectrum[k];
            peakBin = k;
        }
    }

    return peakBin * sampleRate / n;
}

// Analyze harmonics
function analyzeHarmonics(audioData, sampleRate, fundamentalFreq) {
    const segStart = Math.floor(0.1 * sampleRate);
    const segLength = Math.min(8192, audioData.length - segStart);
    if (segLength <= 0) return { sub_bass: 20, fundamental: 100, harmonic2: 30, harmonic3: 10, harmonic4: 5 };

    const segment = audioData.slice(segStart, segStart + segLength);
    const n = segment.length;

    // Apply window
    for (let i = 0; i < n; i++) {
        segment[i] *= 0.5 * (1 - Math.cos(2 * Math.PI * i / n));
    }

    // Measure amplitude at each harmonic frequency
    function measureAmp(targetFreq) {
        const k = Math.round(targetFreq * n / sampleRate);
        let real = 0, imag = 0;
        for (let i = 0; i < n; i++) {
            const angle = 2 * Math.PI * k * i / n;
            real += segment[i] * Math.cos(angle);
            imag -= segment[i] * Math.sin(angle);
        }
        return Math.sqrt(real * real + imag * imag);
    }

    const fundAmp = measureAmp(fundamentalFreq);
    if (fundAmp === 0) return { sub_bass: 20, fundamental: 100, harmonic2: 30, harmonic3: 10, harmonic4: 5 };

    return {
        sub_bass: Math.min(100, Math.round(measureAmp(fundamentalFreq * 0.5) / fundAmp * 100)),
        fundamental: 100,
        harmonic2: Math.min(100, Math.round(measureAmp(fundamentalFreq * 2) / fundAmp * 100)),
        harmonic3: Math.min(100, Math.round(measureAmp(fundamentalFreq * 3) / fundAmp * 100)),
        harmonic4: Math.min(100, Math.round(measureAmp(fundamentalFreq * 4) / fundAmp * 100))
    };
}

// Analyze envelope
function analyzeEnvelope(audioData, sampleRate) {
    // Get amplitude envelope
    const windowSize = Math.floor(0.01 * sampleRate);
    const envelope = [];

    for (let i = 0; i < audioData.length; i += windowSize) {
        let sum = 0;
        for (let j = i; j < Math.min(i + windowSize, audioData.length); j++) {
            sum += Math.abs(audioData[j]);
        }
        envelope.push(sum / windowSize);
    }

    // Normalize
    const maxEnv = Math.max(...envelope);
    if (maxEnv > 0) {
        for (let i = 0; i < envelope.length; i++) envelope[i] /= maxEnv;
    }

    // Find attack (time to 90% of peak)
    const peakIdx = envelope.indexOf(Math.max(...envelope));
    let attackIdx = 0;
    for (let i = 0; i < peakIdx; i++) {
        if (envelope[i] >= 0.9) { attackIdx = i; break; }
    }
    const attackMs = (attackIdx * windowSize / sampleRate) * 1000;

    // Find sustain level
    const sustainStart = Math.floor(envelope.length * 0.3);
    const sustainEnd = Math.floor(envelope.length * 0.6);
    let sustainSum = 0;
    for (let i = sustainStart; i < sustainEnd; i++) sustainSum += envelope[i];
    const sustainLevel = sustainSum / (sustainEnd - sustainStart) || 0.2;

    // Find decay
    let decayIdx = peakIdx;
    for (let i = peakIdx; i < envelope.length; i++) {
        if (envelope[i] <= sustainLevel * 1.1) { decayIdx = i; break; }
    }
    const decayMs = ((decayIdx - peakIdx) * windowSize / sampleRate) * 1000;

    // Find release
    const releaseStart = Math.floor(envelope.length * 0.7);
    const threshold = envelope[releaseStart] * 0.1;
    let releaseIdx = envelope.length;
    for (let i = releaseStart; i < envelope.length; i++) {
        if (envelope[i] <= threshold) { releaseIdx = i; break; }
    }
    const releaseMs = ((releaseIdx - releaseStart) * windowSize / sampleRate) * 1000;

    return {
        attack: Math.max(1, Math.min(200, Math.round(attackMs))),
        decay: Math.max(50, Math.min(2000, Math.round(decayMs))),
        sustain: Math.max(0, Math.min(100, Math.round(sustainLevel * 100))),
        release: Math.max(50, Math.min(2000, Math.round(releaseMs)))
    };
}

// Estimate filter/brightness
function estimateFilterBrightness(audioData, sampleRate, fundamentalFreq) {
    const n = Math.min(8192, audioData.length);
    const segment = audioData.slice(0, n);

    // Apply window
    for (let i = 0; i < n; i++) {
        segment[i] *= 0.5 * (1 - Math.cos(2 * Math.PI * i / n));
    }

    // Calculate spectral centroid
    let sumWeighted = 0, sumAmp = 0;
    for (let k = 1; k < n / 2; k++) {
        const freq = k * sampleRate / n;
        let real = 0, imag = 0;
        for (let i = 0; i < n; i++) {
            const angle = 2 * Math.PI * k * i / n;
            real += segment[i] * Math.cos(angle);
            imag -= segment[i] * Math.sin(angle);
        }
        const amp = Math.sqrt(real * real + imag * imag);
        sumWeighted += freq * amp;
        sumAmp += amp;
    }
    const centroid = sumAmp > 0 ? sumWeighted / sumAmp : 1000;

    // Map to filter and brightness
    const filterCutoff = Math.max(500, Math.min(10000, Math.round(centroid * 3)));
    const brightnessRatio = fundamentalFreq > 0 ? centroid / fundamentalFreq : 2;
    const brightness = Math.max(0, Math.min(100, Math.round((brightnessRatio - 1) * 25 + 50)));

    return { filter: filterCutoff, brightness: brightness };
}

// Analyze a single audio buffer and return results
async function analyzeSingleAudio(file) {
    const arrayBuffer = await file.arrayBuffer();
    const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer.slice(0));  // slice to avoid detached buffer

    // Get mono audio data
    const audioData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;

    // Detect pitch
    const freqAuto = detectPitchAutocorr(Float32Array.from(audioData), sampleRate);
    const freqFFT = detectPitchFFT(Float32Array.from(audioData), sampleRate);
    const freq = Math.abs(freqFFT - freqAuto) > freqAuto * 0.1 ? freqFFT : (freqAuto + freqFFT) / 2;

    const { note, octave } = freqToNote(freq);
    const detectedNote = `${note}${octave}`;

    // Check if on pan
    const onPan = TENOR_PAN_NOTES.includes(detectedNote) ||
                  TENOR_PAN_NOTES.includes(detectedNote.replace('#', 'b'));

    // Analyze components
    const harmonics = analyzeHarmonics(Float32Array.from(audioData), sampleRate, freq);
    const envelope = analyzeEnvelope(Float32Array.from(audioData), sampleRate);
    const filterBright = estimateFilterBrightness(Float32Array.from(audioData), sampleRate, freq);

    return {
        filename: file.name,
        audioBuffer: audioBuffer,
        audioData: audioData,
        sampleRate: sampleRate,
        detectedNote: detectedNote,
        frequency: freq,
        onPan: onPan,
        params: {
            attack: envelope.attack,
            decay: envelope.decay,
            sustain: envelope.sustain,
            release: envelope.release,
            fundamental: harmonics.fundamental,
            harm2: harmonics.harmonic2,
            harm3: harmonics.harmonic3,
            harm4: harmonics.harmonic4,
            subBass: harmonics.sub_bass,
            detune: 2,
            filter: filterBright.filter,
            brightness: filterBright.brightness,
            duration: audioData.length / sampleRate,
            volume: 85
        }
    };
}

// Main analysis function for multiple files
async function analyzeMultipleAudio(event) {
    const files = Array.from(event.target.files);
    if (files.length === 0) return;

    initAudio();

    const resultDiv = document.getElementById('analysisResult');
    const fileListDiv = document.getElementById('fileList');
    const fileListContent = document.getElementById('fileListContent');

    resultDiv.innerHTML = `<span style="color: #FFD700;">Analyzing ${files.length} file(s)...</span>`;

    allAnalysisResults = [];

    for (let i = 0; i < files.length; i++) {
        try {
            resultDiv.innerHTML = `<span style="color: #FFD700;">Analyzing ${i + 1}/${files.length}: ${files[i].name}</span>`;
            const result = await analyzeSingleAudio(files[i]);
            allAnalysisResults.push(result);
        } catch (err) {
            console.error(`Error analyzing ${files[i].name}:`, err);
            allAnalysisResults.push({
                filename: files[i].name,
                error: err.message
            });
        }
    }

    // Display file list if multiple files
    if (allAnalysisResults.length > 1) {
        fileListDiv.style.display = 'block';
        fileListContent.innerHTML = allAnalysisResults.map((r, i) => {
            if (r.error) {
                return `<div style="padding: 4px; color: #ff4444; cursor: default;">${r.filename}: Error</div>`;
            }
            const onPanIcon = r.onPan ? '&#10003;' : '&#10007;';
            const onPanColor = r.onPan ? '#00ff88' : '#ff6644';
            return `<div class="file-item" data-index="${i}" onclick="selectAnalysisResult(${i})"
                        style="padding: 4px; cursor: pointer; border-radius: 3px; margin: 2px 0; ${i === 0 ? 'background: #333;' : ''}">
                <span style="color: ${onPanColor};">${onPanIcon}</span>
                <strong>${r.detectedNote}</strong> (${r.frequency.toFixed(0)}Hz) - ${r.filename}
            </div>`;
        }).join('');

        // Show summary
        const validResults = allAnalysisResults.filter(r => !r.error);
        const onPanCount = validResults.filter(r => r.onPan).length;
        resultDiv.innerHTML = `
            <div style="color: #FFD700; font-weight: bold;">Analyzed ${validResults.length} files</div>
            <div style="color: #00ff88;">${onPanCount} notes on tenor pan</div>
            <div style="margin-top: 5px; color: #888;">Click a file above to view details</div>
        `;
    } else {
        fileListDiv.style.display = 'none';
    }

    // Select first valid result
    const firstValid = allAnalysisResults.findIndex(r => !r.error);
    if (firstValid >= 0) {
        selectAnalysisResult(firstValid);
    }

    event.target.value = '';
}

// Select a specific analysis result
function selectAnalysisResult(index) {
    const result = allAnalysisResults[index];
    if (!result || result.error) return;

    selectedResultIndex = index;

    // Update selection highlight
    document.querySelectorAll('.file-item').forEach((el, i) => {
        el.style.background = i === index ? '#333' : 'transparent';
    });

    // Update current buffers and params
    loadedAudioBuffer = result.audioBuffer;
    analyzedParams = result.params;

    // Update display for single file mode or show selected file details
    const resultDiv = document.getElementById('analysisResult');

    if (allAnalysisResults.length === 1) {
        // Single file - show full details
        resultDiv.innerHTML = `
            <div style="color: #00ff88; font-weight: bold;">Detected: ${result.detectedNote} (${result.frequency.toFixed(1)} Hz)</div>
            <div style="color: ${result.onPan ? '#00ff88' : '#ff6644'};">
                ${result.onPan ? 'On tenor pan' : 'Not on tenor pan'}
            </div>
            <div style="margin-top: 5px;">
                <strong>Envelope:</strong> A=${result.params.attack}ms D=${result.params.decay}ms S=${result.params.sustain}% R=${result.params.release}ms
            </div>
            <div>
                <strong>Harmonics:</strong> Sub=${result.params.subBass}% H2=${result.params.harm2}% H3=${result.params.harm3}% H4=${result.params.harm4}%
            </div>
            <div>
                <strong>Character:</strong> Filter=${result.params.filter}Hz Bright=${result.params.brightness}%
            </div>
        `;
    } else {
        // Multiple files - show summary + selected file details
        const validResults = allAnalysisResults.filter(r => !r.error);
        const onPanCount = validResults.filter(r => r.onPan).length;
        resultDiv.innerHTML = `
            <div style="color: #FFD700; font-weight: bold;">Analyzed ${validResults.length} files (${onPanCount} on pan)</div>
            <div style="margin-top: 5px; padding: 5px; background: #222; border-radius: 4px;">
                <div style="color: #00ff88;"><strong>${result.filename}</strong></div>
                <div>${result.detectedNote} (${result.frequency.toFixed(1)} Hz) - ${result.onPan ? 'On pan' : 'Not on pan'}</div>
                <div style="font-size: 10px; color: #888;">A=${result.params.attack} D=${result.params.decay} S=${result.params.sustain} R=${result.params.release}</div>
            </div>
        `;
    }

    // Show buttons and visualization
    document.getElementById('applyBtns').style.display = 'flex';
    document.getElementById('loadedAudioVizContainer').style.display = 'block';
    drawLoadedAudioWaveform(result.audioData, result.sampleRate);
}

// Legacy single file function (calls multi-file with single file)
async function analyzeAudio(event) {
    return analyzeMultipleAudio(event);
}

// Draw loaded audio waveform
function drawLoadedAudioWaveform(audioData, sampleRate) {
    const canvas = document.getElementById('loadedAudioViz');
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    if (rect.width === 0) return;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    const width = rect.width;
    const height = rect.height;

    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, width, height);

    // Draw waveform
    ctx.strokeStyle = '#ff6600';
    ctx.lineWidth = 1;
    ctx.beginPath();

    const step = Math.ceil(audioData.length / width);
    for (let i = 0; i < width; i++) {
        const idx = i * step;
        let min = 1, max = -1;
        for (let j = 0; j < step && idx + j < audioData.length; j++) {
            const val = audioData[idx + j];
            if (val < min) min = val;
            if (val > max) max = val;
        }
        const y1 = (1 - max) * height / 2;
        const y2 = (1 - min) * height / 2;
        ctx.moveTo(i, y1);
        ctx.lineTo(i, y2);
    }
    ctx.stroke();
}

// Apply analyzed parameters to synth
function applyAnalyzedParams() {
    if (!analyzedParams) return;

    const paramMap = {
        attack: 'attack', decay: 'decay', sustain: 'sustain', release: 'release',
        fundamental: 'fundamental', harm2: 'harm2', harm3: 'harm3', harm4: 'harm4',
        subBass: 'subBass', detune: 'detune', filter: 'filter', brightness: 'brightness',
        volume: 'volume'
    };

    for (const [key, sliderId] of Object.entries(paramMap)) {
        const slider = document.getElementById(sliderId);
        if (slider && analyzedParams[key] !== undefined) {
            slider.value = analyzedParams[key];
            updateSliderDisplay(sliderId);
        }
    }

    // Duration
    const durationSlider = document.getElementById('duration');
    if (durationSlider && analyzedParams.duration) {
        durationSlider.value = Math.min(3, Math.max(0.5, analyzedParams.duration));
        updateSliderDisplay('duration');
    }

    validateADSR();
    updateCLICommand();
    updateStaticViz();

    document.getElementById('fileStatus').textContent = 'Parameters applied from analysis';
    setTimeout(() => document.getElementById('fileStatus').textContent = '', 3000);
}

// Play loaded audio
function playLoadedAudio() {
    if (!loadedAudioBuffer || !audioCtx) return;

    const source = audioCtx.createBufferSource();
    source.buffer = loadedAudioBuffer;
    source.connect(audioCtx.destination);
    source.start();
}

// Initialize
document.addEventListener('DOMContentLoaded', setup);
</script>
</body>
</html>
